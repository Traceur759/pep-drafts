<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Docutils 0.13.1: http://docutils.sourceforge.net/" />
  <title>PEP C -- Module State Access from C Extension Methods</title>
  <style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@python.org
:date: $Date: 2006-05-21 22:44:42 +0200 (So, 21. Mai 2006) $
:version: $Revision: 4564 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the PEP HTML output of Docutils.
*/

/* "! important" is used here to override other ``margin-top`` and
   ``margin-bottom`` styles that are later in the stylesheet or 
   more specific.  See http://www.w3.org/TR/CSS1#the-cascade */
.first {
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.navigation {
  width: 100% ;
  background: #99ccff ;
  margin-top: 0px ;
  margin-bottom: 0px }

.navigation .navicon {
  width: 150px ;
  height: 35px }

.navigation .textlinks {
  padding-left: 1em ;
  text-align: left }

.navigation td, .navigation th {
  padding-left: 0em ;
  padding-right: 0em ;
  vertical-align: middle }

.rfc2822 {
  margin-top: 0.5em ;
  margin-left: 0.5em ;
  margin-right: 0.5em ;
  margin-bottom: 0em }

.rfc2822 td {
  text-align: left }

.rfc2822 th.field-name {
  text-align: right ;
  font-family: sans-serif ;
  padding-right: 0.5em ;
  font-weight: bold ;
  margin-bottom: 0em }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

body {
  margin: 0px ;
  margin-bottom: 1em ;
  padding: 0px }

dl.docutils dd {
  margin-bottom: 0.5em }

div.section {
  margin-left: 1em ;
  margin-right: 1em ;
  margin-bottom: 1.5em }

div.section div.section {
  margin-left: 0em ;
  margin-right: 0em ;
  margin-top: 1.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.footer {
  margin-left: 1em ;
  margin-right: 1em }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1 {
  font-family: sans-serif ;
  font-size: large }

h2 {
  font-family: sans-serif ;
  font-size: medium }

h3 {
  font-family: sans-serif ;
  font-size: small }

h4 {
  font-family: sans-serif ;
  font-style: italic ;
  font-size: small }

h5 {
  font-family: sans-serif;
  font-size: x-small }

h6 {
  font-family: sans-serif;
  font-style: italic ;
  font-size: x-small }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

img.borderless {
  border: 0 }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-family: sans-serif ;
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

td.num {
  text-align: right }

th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body bgcolor="white">
<table class="navigation" cellpadding="0" cellspacing="0"
       width="100%" border="0">
<tr><td class="navicon" width="150" height="35">
<a href="http://www.python.org/" title="Python Home Page">
<img src="http://www.python.org/pics/PyBanner000.gif" alt="[Python]"
 border="0" width="150" height="35" /></a></td>
<td class="textlinks" align="left">
[<b><a href="http://www.python.org/">Python Home</a></b>]
[<b><a href="index.html">PEP Index</a></b>]
[<b><a href="https://github.com/fedora-python/pep-drafts/blob/master/pep-C.rst">PEP Source</a></b>]
</td></tr></table>
<div class="document">
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">XXX</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Module State Access from C Extension Methods</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body">$Date$</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Petr Viktorin &lt;<a class="reference external" href="mailto:encukou&#64;gmail.com">encukou&#64;gmail.com</a>&gt;,
Nick Coghlan &lt;<a class="reference external" href="mailto:ncoghlan&#64;gmail.com">ncoghlan&#64;gmail.com</a>&gt;,
Eric Snow &lt;<a class="reference external" href="mailto:ericsnowcurrently&#64;gmail.com">ericsnowcurrently&#64;gmail.com</a>&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body"><a class="reference external" href="mailto:import-sig&#64;python.org">import-sig&#64;python.org</a></td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Active</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Process</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body">text/x-rst</td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">02-Jun-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id7">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id8">Rationale</a><ul>
<li><a class="reference internal" href="#static-exceptions" id="id9">Static Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#background" id="id10">Background</a></li>
<li><a class="reference internal" href="#proposal" id="id11">Proposal</a><ul>
<li><a class="reference internal" href="#slot-methods" id="id12">Slot methods</a></li>
<li><a class="reference internal" href="#id2" id="id13">Static Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification" id="id14">Specification</a><ul>
<li><a class="reference internal" href="#adding-module-references-to-heap-types" id="id15">Adding module references to heap types</a></li>
<li><a class="reference internal" href="#passing-the-defining-class-to-extension-methods" id="id16">Passing the defining class to extension methods</a></li>
<li><a class="reference internal" href="#argument-clinic" id="id17">Argument Clinic</a></li>
<li><a class="reference internal" href="#id3" id="id18">Slot methods</a></li>
<li><a class="reference internal" href="#id4" id="id19">Static exceptions</a></li>
<li><a class="reference internal" href="#helpers" id="id20">Helpers</a></li>
<li><a class="reference internal" href="#modules-converted-in-the-initial-implementation" id="id21">Modules Converted in the Initial Implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-api-changes-and-additions" id="id22">Summary of API Changes and Additions</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id23">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#implementation" id="id24">Implementation</a></li>
<li><a class="reference internal" href="#possible-future-extensions" id="id25">Possible Future Extensions</a><ul>
<li><a class="reference internal" href="#easy-creation-of-types-with-module-references" id="id26">Easy creation of types with module references</a></li>
<li><a class="reference internal" href="#optimization" id="id27">Optimization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id28">References</a></li>
<li><a class="reference internal" href="#copyright" id="id29">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id7">Abstract</a></h1>
<p>This PEP proposes to add a way for CPython extension methods to access context such as
the state of the modules they are defined in.</p>
<p>This will allow extension methods to use direct pointer dereferences
rather than PyState_FindModule for looking up module state, reducing or eliminating the
performance cost of using module-scoped state over process global state.</p>
<p>This fixes one of the remaining roadblocks for adoption of <a class="reference external" href="http://www.python.org/dev/peps/pep-3121">PEP 3121</a> (Extension
module initialization and finalization) and <a class="reference external" href="http://www.python.org/dev/peps/pep-0489">PEP 489</a>
(Multi-phase extension module initialization).</p>
<p>Additionaly, support for easier creation of static exception classes is added.
This removes the need for keeping per-module state if it would only be used
for exception classes.</p>
<p>While this PEP takes an additional step towards fully solving the problems that <a class="reference external" href="http://www.python.org/dev/peps/pep-3121">PEP 3121</a> and <a class="reference external" href="http://www.python.org/dev/peps/pep-0489">PEP 489</a> started
tackling, it does not attempt to resolve <em>all</em> remaining concerns. In particular, accessing the module state from slot methods (<tt class="docutils literal">nb_add</tt>, etc) remains slower than accessing that state from other extension methods.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id8">Rationale</a></h1>
<p><a class="reference external" href="http://www.python.org/dev/peps/pep-0489">PEP 489</a> introduced a new way to initialize extension modules, which brings
several advantages to extensions that implement it:</p>
<blockquote>
<ul class="simple">
<li>The extension modules behave more like their Python counterparts.</li>
<li>The extension modules can easily support loading into pre-existing
module objects, which paves the way for extension module support for
<tt class="docutils literal">runpy</tt> or for systems that enable extension module reloading.</li>
<li>Loading multiple modules from the same extension is possible, which
makes testing module isolation (a key feature for proper sub-interpreter
support) possible from a single interpreter.</li>
</ul>
</blockquote>
<p>The biggest hurdle for adoption of <a class="reference external" href="http://www.python.org/dev/peps/pep-0489">PEP 489</a> is allowing access to module state
from methods of extension types.
Currently, the way to access this state from extension methods is by looking up the module via
<tt class="docutils literal">PyState_FindModule</tt> (in contrast to module level functions in extension modules, which
receive a module reference as an argument).
However, <tt class="docutils literal">PyState_FindModule</tt> queries the thread-local state, making it relatively
costly compared to C level process global access and consequently deterring module authors from using it.</p>
<p>Also, <tt class="docutils literal">PyState_FindModule</tt> relies on the assumption that in each
subinterpreter, there is at most one module corresponding to
a given <tt class="docutils literal">PyModuleDef</tt>.  This does not align well with Python's import
machinery.  Since <a class="reference external" href="http://www.python.org/dev/peps/pep-0489">PEP 489</a> aimed to fix that,  the assumption does
not hold for modules that use multi-phase initialization, so
<tt class="docutils literal">PyState_FindModule</tt> is unavailable for these modules.</p>
<p>A faster, safer way of accessing module-level state from extension methods
is needed.</p>
<div class="section" id="static-exceptions">
<h2><a class="toc-backref" href="#id9">Static Exceptions</a></h2>
<p>For isolated modules to work, any class whose methods touch module state
must be a heap class, so that each instance of a module can have its own
class object.  With the changes proposed in this PEP, heap classes will
provide access to module state without global registration.  But, to create
instances of heap classes, one will need the module state in order to
get the class object corresponding to the appropriate module object.
Heap types are &quot;viral&quot; – anything that “touches” them must itself be
a heap type.</p>
<p>Curently, most exception types, apart from the ones in <tt class="docutils literal">builtins</tt>, are
heap types.  This is likely simply because there is a convenient way
to create them: <tt class="docutils literal">PyErr_NewException</tt>.  Most exceptions do not need to be
heap types.  (It does give Python code the ability to add custom attributes
to the exception class, but monkeypatching exception classes is not very
useful).
In some cases, heap exception types are harmful.  For example the <tt class="docutils literal">sqlite</tt>
module currently uses C-global variables for the exceptions, so any time the
module is loaded (e.g. from a subinterpreter), these pointers will be
overwritten with freshly created classes. It seems like the module was
written expecting <tt class="docutils literal">PyErr_NewException</tt> to hand out static types – which
is an assumption that someone casually reading the docs could very well form.</p>
<p>Moreover, since raising exception is a common operations, and heap types
will be &quot;viral&quot;, <tt class="docutils literal">PyErr_NewException</tt> will tend to &quot;infect&quot; the module
with &quot;heap-type-ness&quot; – at least if the module decides play well with
subinterpreters/isolation.  Many modules could go without module state
entirely if the exception classes were static.</p>
<p>To solve this problem, a new function for creating static exception types
is proposed.</p>
</div>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id10">Background</a></h1>
<p>The implementation of a Python method may need access to one or more of
the following pieces of information:</p>
<blockquote>
<ul class="simple">
<li>The instance it is called on (<tt class="docutils literal">self</tt>)</li>
<li>The underlying function</li>
<li>The class the method was defined in</li>
<li>The corresponding module</li>
<li>The module state</li>
</ul>
</blockquote>
<p>In Python code, the Python-level equivalents may be retrieved as:</p>
<pre class="literal-block">
import sys

class Foo:
    def meth(self):
        instance = self
        module_globals = globals()
        module_object = sys.modules[__name__]
        underlying_function = Foo.meth
        defining_class = Foo
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The defining class is not <tt class="docutils literal">type(self)</tt>, since <tt class="docutils literal">type(self)</tt> might
be a subclass of <tt class="docutils literal">Foo</tt>.</p>
</div>
<p>Implicitly, the last three of those rely on name-based lookup via the function's <tt class="docutils literal">__globals__</tt> attribute:
either the <tt class="docutils literal">Foo</tt> attribute to access the defining class and Python function object, or <tt class="docutils literal">__name__</tt> to find the module object in <tt class="docutils literal">sys.modules</tt>.
In Python code, this is feasible, as <tt class="docutils literal">__globals__</tt> is set appropriately when the function definition is executed, and
even if the namespace has been manipulated to return a different object, at worst an exception will be raised.</p>
<p>By contrast, extension methods are typically implemented as normal C functions. This means that they only have access to their arguments, and any C level thread local and process global state. Traditionally, many extension modules have stored
their shared state in C level process globals, causing problems when:</p>
<blockquote>
<ul class="simple">
<li>running multiple initialize/finalize cycles in the same process</li>
<li>reloading modules (e.g. to test conditional imports)</li>
<li>loading extension modules in subinterpreters</li>
</ul>
</blockquote>
<p><a class="reference external" href="http://www.python.org/dev/peps/pep-3121">PEP 3121</a> attempted to resolve this by offering the <tt class="docutils literal">PyState_FindModule</tt> API, but this still had significant problems when it comes to extension methods (rather than module level functions):</p>
<blockquote>
<ul class="simple">
<li>it is markedly slower than directly accessing C level process global state</li>
<li>there is still some inherent reliance on process global state that means it still doesn't reliably handle module reloading</li>
</ul>
</blockquote>
<p>It's also the case that when looking up a C-level struct such as module state, supplying
an unexpected object layout can crash the interpreter, so it's significantly more important to ensure that extension
methods receive the kind of object they expect.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id11">Proposal</a></h1>
<p>Currently, a bound extension method (<tt class="docutils literal">PyCFunction</tt> or <tt class="docutils literal">PyCFunctionWithKeywords</tt>) receives only
<tt class="docutils literal">self</tt>, and (if applicable) the supplied positional and keyword arguments.</p>
<p>While module-level extension functions already receive access to the defining module object via their
<tt class="docutils literal">self</tt> argument, methods of extension types don't have that luxury: they receive the bound instance
via <tt class="docutils literal">self</tt>, and hence have no direct access to the defining class or the module level state.</p>
<p>The additional module level context described above can be made available with two changes.
Both additions are optional; extension authors need to opt in to start
using them:</p>
<blockquote>
<ul>
<li><p class="first">Add a pointer to the module to heap type objects.</p>
</li>
<li><p class="first">Pass the defining class to the underlying C function.</p>
<p>The defining class is readily available at the time built-in
method objects (<tt class="docutils literal">PyCFunctionObject</tt>) are created, so it can be stored
in a new struct that extends <tt class="docutils literal">PyCFunctionObject</tt>.</p>
</li>
</ul>
</blockquote>
<p>The module state can then be retrieved from the module object via
<tt class="docutils literal">PyModule_GetState</tt>.</p>
<p>Note that this proposal implies that any type whose method needs to access
module-global state must be a heap type dynamically created during extension
module initialisation, rather than a static type predefined when the extension
module is compiled.</p>
<p>This is necessary to support loading multiple module objects from a single
extension: a static type, as a C-level global, has no information about
which module it belongs to.</p>
<div class="section" id="slot-methods">
<h2><a class="toc-backref" href="#id12">Slot methods</a></h2>
<p>The above changes don't cover slot methods, such as <tt class="docutils literal">tp_iter</tt> or <tt class="docutils literal">nb_add</tt>.</p>
<p>The problem with slot methods is that their C API is fixed, so we can't
simply add a new argument to pass in the defining class.
Two possible solutions have been proposed to this problem:</p>
<blockquote>
<ul class="simple">
<li>Look up the class through walking the MRO.
This is potentially expensive, but will be useful if performance is not
a problem (such as when raising a module-level exception).</li>
<li>Storing a pointer to the defining class of each slot in a separate table,
<tt class="docutils literal">__typeslots__</tt> <a class="footnote-reference" href="#typeslots-mail" id="id1">[1]</a>.  This is technically feasible and fast,
but quite invasive.</li>
</ul>
</blockquote>
<p>Due to the invasiveness of the latter approach, this PEP proposes adding a MRO walking helper for use in slot method implementations, deferring the more complex alternative as a potential future optimisation.</p>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id13">Static Exceptions</a></h2>
<p>To faciliate creating static exception classes, a new function is proposed:
<tt class="docutils literal">PyErr_PrepareStaticException</tt>. It will work similarly to
<tt class="docutils literal">PyErr_NewExceptionWithDoc</tt>, but it will take a pre-allocated, zero-filled
<tt class="docutils literal">PyTypeObject</tt>, fill it with the provided info, and call <tt class="docutils literal">PyType_Ready</tt>
on it.</p>
</div>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id14">Specification</a></h1>
<div class="section" id="adding-module-references-to-heap-types">
<h2><a class="toc-backref" href="#id15">Adding module references to heap types</a></h2>
<p>The <tt class="docutils literal">PyHeapTypeObject</tt> struct will get a new member, <tt class="docutils literal">PyObject *ht_module</tt>,
that can store a pointer to the module object for which the type was defined.
It will be <tt class="docutils literal">NULL</tt> by default, and should not be modified after the type
object is created.</p>
<p>A new flag, <tt class="docutils literal">Py_TPFLAGS_HAVE_MODULE</tt>, will be set on any type object where
the <tt class="docutils literal">ht_module</tt> member is present and non-NULL.</p>
<p>A new factory method will be added for creating modules:</p>
<pre class="literal-block">
PyObject* PyType_FromModuleAndSpec(PyObject *module,
                                   PyType_Spec *spec,
                                   PyObject *bases)
</pre>
<p>This acts the same as <tt class="docutils literal">PyType_FromSpecWithBases</tt>, and additionally sets
<tt class="docutils literal">ht_module</tt> to the provided module object.</p>
<p>Additionally, an accessor, <tt class="docutils literal">PyObject * PyType_GetModule(PyTypeObject *)</tt>
will be provided.
It will return the <tt class="docutils literal">ht_module</tt> if a heap type with Py_TPFLAGS_HAVE_MODULE is passed in,
otherwise it will set a SystemError and return NULL.</p>
<p>Usually, creating a class with <tt class="docutils literal">ht_module</tt> set will create a reference
cycle involving the class and the module.
This is not a problem, as tearing down modules is not a performance-sensitive
operation.
Module-level functions typically also create reference cycles.</p>
</div>
<div class="section" id="passing-the-defining-class-to-extension-methods">
<h2><a class="toc-backref" href="#id16">Passing the defining class to extension methods</a></h2>
<p>A new style of C-level functions will be added to the current selection of
<tt class="docutils literal">PyCFunction</tt> and <tt class="docutils literal">PyCFunctionWithKeywords</tt>:</p>
<pre class="literal-block">
PyObject *PyCMethod(PyObject *self,
                    PyTypeObject *defining_class,
                    PyObject *args, PyObject *kwargs)
</pre>
<p>A new method object flag, <tt class="docutils literal">METH_METHOD</tt>, will be added to signal that
the underlying C function is <tt class="docutils literal">PyCMethod</tt>.</p>
<p>To hold the extra information, a new structure extending <tt class="docutils literal">PyCFunctionObject</tt>
will be added:</p>
<pre class="literal-block">
typedef struct {
    PyCFunctionObject func;
    PyTypeObject *mm_class; /* Passed as 'defining_class' arg to the C func */
} PyCMethodObject;
</pre>
<p>Method construction and calling code and will be updated to honor
<tt class="docutils literal">METH_METHOD</tt>.</p>
</div>
<div class="section" id="argument-clinic">
<h2><a class="toc-backref" href="#id17">Argument Clinic</a></h2>
<p>To support passing the defining class to methods using Argument Clinic,
a new converter will be added to clinic.py: <tt class="docutils literal">definitng_class</tt>.</p>
<p>Each method may only have one argument using this converter, and it must
appear after <tt class="docutils literal">self</tt>, or, if <tt class="docutils literal">self</tt> is not used, as the first argument.
The argument will be of type <tt class="docutils literal">PyTypeObject *</tt>.</p>
<p>When used, Argument Clinic will select <tt class="docutils literal">METH_METHOD</tt> as the calling
convention.
The argument will not appear in <tt class="docutils literal">__text_signature__</tt>.</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id18">Slot methods</a></h2>
<p>XXX: Exact API TBD</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id19">Static exceptions</a></h2>
<p>A new function will be added:</p>
<pre class="literal-block">
PyTypeObject * PyErr_PrepareStaticException(PyTypeObject *exc,
                                            const char *name,
                                            const char *doc,
                                            PyObject *base)
</pre>
<p>Given a zero-filled exception type <tt class="docutils literal">exc</tt>, it will fill that object's
<tt class="docutils literal">tp_name</tt>, <tt class="docutils literal">tp_doc</tt> and <tt class="docutils literal">tp_base</tt> with the provided information.
The <tt class="docutils literal">doc</tt> and <tt class="docutils literal">base</tt> arguments may be <tt class="docutils literal">NULL</tt>, defaulting to a
missing docstring and <tt class="docutils literal">PyExc_Exception</tt> base class, respectively.
The exception type's <tt class="docutils literal">tp_flags</tt> will be set to values common to
built-in exceptions.
After filling these slots, the function will call <tt class="docutils literal">PyType_Ready</tt> on
the exception class, and return it.
On failure, <tt class="docutils literal">PyErr_PrepareStaticException</tt> will set an exception
and return NULL.</p>
<p>If called with an initialized exception type (determined by <tt class="docutils literal">Py_TYPE(exc)</tt>
being non-NULL), the function will do nothing but return <tt class="docutils literal">exc</tt>.</p>
<p>The function will not be part of the stable ABI, since it needs the module
to pre-allocate a <tt class="docutils literal">PyTypeObject</tt>.</p>
<p>Since heap types do not support multiple inheritance, the function will
only allow a single type for <tt class="docutils literal">base</tt>.</p>
</div>
<div class="section" id="helpers">
<h2><a class="toc-backref" href="#id20">Helpers</a></h2>
<p>XXX: I'd like to port a bunch of modules to see what helpers would be convenient</p>
</div>
<div class="section" id="modules-converted-in-the-initial-implementation">
<h2><a class="toc-backref" href="#id21">Modules Converted in the Initial Implementation</a></h2>
<p>To validate the approach, several modules will be modified during
the initial implementation:</p>
<p>The <tt class="docutils literal">_sqlite</tt>, <tt class="docutils literal">_pickle</tt>, <tt class="docutils literal">_elementtree</tt>, <tt class="docutils literal">_curses_panel</tt> and
<tt class="docutils literal">_csv</tt> modules will be switched to use static exception types.</p>
<p>XXX: Module state</p>
</div>
</div>
<div class="section" id="summary-of-api-changes-and-additions">
<h1><a class="toc-backref" href="#id22">Summary of API Changes and Additions</a></h1>
<p>XXX, see above for now</p>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id23">Backwards Compatibility</a></h1>
<p>One new pointer is added to all heap types.
All other changes are adding new functions and structures.</p>
<p>The new <tt class="docutils literal">PyErr_PrepareStaticException</tt> function changes encourages
modules to switch from using heap-type Exception classes to static ones,
and a number of modules will be switched in the initial implementation.
This change will prevent adding class attributes to such types.
For example, the following will raise AttributeError:</p>
<pre class="literal-block">
sqlite.OperationalError.foo = None
</pre>
<p>Instances and subclasses of such exceptions will not be affected.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id24">Implementation</a></h1>
<p>An initial implementation is available in a Github repository <a class="footnote-reference" href="#gh-repo" id="id5">[2]</a>;
a patchset is at <a class="footnote-reference" href="#gh-patch" id="id6">[3]</a>.</p>
</div>
<div class="section" id="possible-future-extensions">
<h1><a class="toc-backref" href="#id25">Possible Future Extensions</a></h1>
<div class="section" id="easy-creation-of-types-with-module-references">
<h2><a class="toc-backref" href="#id26">Easy creation of types with module references</a></h2>
<p>It would be possible to add a <a class="reference external" href="http://www.python.org/dev/peps/pep-0489">PEP 489</a> execution slot type make
creating heap types significantly easier than calling
<tt class="docutils literal">PyType_FromModuleAndSpec</tt>.
This is left to a future PEP.</p>
</div>
<div class="section" id="optimization">
<h2><a class="toc-backref" href="#id27">Optimization</a></h2>
<p>CPython optimizes calls to methods that have restricted signatures,
such as not allowing keyword arguments.</p>
<p>As proposed here, methods defined with the <tt class="docutils literal">METH_METHOD</tt> flag do not support
these optimizations.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id28">References</a></h1>
<table class="docutils footnote" frame="void" id="typeslots-mail" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>[Import-SIG] On singleton modules, heap types, and subinterpreters
(<a class="reference external" href="https://mail.python.org/pipermail/import-sig/2015-July/001035.html">https://mail.python.org/pipermail/import-sig/2015-July/001035.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gh-repo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td><a class="reference external" href="https://github.com/encukou/cpython/commits/module-state-access">https://github.com/encukou/cpython/commits/module-state-access</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gh-patch" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[3]</a></td><td><a class="reference external" href="https://github.com/encukou/cpython/compare/master...encukou:module-state-access.patch">https://github.com/encukou/cpython/compare/master...encukou:module-state-access.patch</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id29">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

</div>
</body>
</html>
